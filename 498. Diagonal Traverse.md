
## [498. Diagonal Traverse](https://leetcode.com/problems/diagonal-traverse/)
Given an  `m x n`  matrix  `mat`, return  _an array of all the elements of the array in a diagonal order_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg)

**Input:** mat = [[1,2,3],[4,5,6],[7,8,9]]
**Output:** [1,2,4,7,5,3,6,8,9]

**Example 2:**
**Input:** mat = [[1,2],[3,4]]
**Output:** [1,2,3,4]

**Constraints:**
-   `m == mat.length`
-   `n == mat[i].length`
-   `1 <= m, n <= 104`
-   `1 <= m * n <= 104`
-   `-105 <= mat[i][j] <= 105`

---
----------

## 🔥 Method 1: Your Code (Simulation by Diagonals)
### 🔹 Idea
-   There are `m+n-1` diagonals.
-   For **even d**, go **up-right** (row decreases, col increases).
-   For **odd d**, go **down-left** (row increases, col decreases).
----------
### 🔹 Algorithm
1.  Loop over diagonal index `d` from `0` to `m+n-2`.
2.  Compute starting `(r, c)` based on `d`. 
3.  Move along diagonal until out of bounds.
4.  Append elements to result.
----------

### 🔹 Pseudocode
```
for d = 0 to m+n-2:
    if d even:
        r = min(d, m-1)
        c = d - r
        while r >= 0 and c < n:
            push mat[r][c]
            r--, c++
    else:
        c = min(d, n-1)
        r = d - c
        while c >= 0 and r < m:
            push mat[r][c]
            r++, c--
```
----------

### 🔹 C++ Code
```cpp
class Solution 
{
	public:
    vector<int> findDiagonalOrder(vector<vector<int>>& mat) 
    {
        if (mat.empty()) return {};
        int m = mat.size(), n = mat[0].size();
        vector<int> result;
        result.reserve(m * n);

        for (int d = 0; d < m + n - 1; d++) 
        {
            if (d % 2 == 0) 
            {
                int r = (d < m) ? d : m - 1;
                int c = d - r;
                while (r >= 0 && c < n) 
                {
                    result.push_back(mat[r][c]);
                    r--; c++;
                }
            } 
            else 
            {
                int c = (d < n) ? d : n - 1;
                int r = d - c;
                while (c >= 0 && r < m) 
                {
                    result.push_back(mat[r][c]);
                    r++; c--;
                }
            }
        }
        return result;
    }
};
```
----------

### 🔹 Complexity
-   **Time:** `O(m*n)`
-   **Space:** `O(1)` extra
----------

### 🔹 Suggestion
✅ Clean, efficient, interview-ready. This is **the best balance** of clarity and performance.

----------

## 🔥 Method 2: Mathematical Formula (Elegant Index Calculation)
### 🔹 Idea
Use **mathematical formulas** to avoid manual simulation:
-   `row_start = max(0, d - (n-1))`
-   `row_end = min(d, m-1)`
-   `col = d - row`
----------

### 🔹 Algorithm
1.  Loop over each diagonal `d`.
2.  Calculate `row_start` and `row_end`.
3.  Traverse rows either forward or backward based on parity of `d`.
----------
### 🔹 Pseudocode
```
for d = 0 to m+n-2:
    row_start = max(0, d - (n-1))
    row_end = min(d, m-1)
    if d even:
        for r = row_end downto row_start:
            c = d - r
            push mat[r][c]
    else:
        for r = row_start to row_end:
            c = d - r
            push mat[r][c]

```
----------

### 🔹 C++ Code
```cpp
class Solution 
{
	public:
    vector<int> findDiagonalOrder(vector<vector<int>>& mat) 
    {
        int m = mat.size(), n = mat[0].size();
        vector<int> result;
        result.reserve(m * n);

        for (int d = 0; d < m + n - 1; d++) 
        {
            int row_start = max(0, d - (n - 1));
            int row_end = min(d, m - 1);

            if (d % 2 == 0) {
                for (int r = row_end; r >= row_start; r--) 
                {
                    result.push_back(mat[r][d - r]);
                }
            } 
            else 
            {
                for (int r = row_start; r <= row_end; r++) 
                {
                    result.push_back(mat[r][d - r]);
                }
            }
        }
        return result;
    }
};
```
----------

### 🔹 Complexity
-   **Time:** `O(m*n)`
-   **Space:** `O(1)` extra
----------

### 🔹 Suggestion
✅ Most **elegant mathematical solution**.  
No boundary checks inside loops → great for **competitive programming**.

----------

## 🔥 Method 3: HashMap of Diagonals (Group by d = r+c)

### 🔹 Idea
-   Each element belongs to a diagonal `d = r + c`.
-   Group all elements in `diag[d]`.
-   Reverse even diagonals before appending.
----------

### 🔹 Algorithm
1.  Create `vector<vector<int>> diag(m+n-1)`.
2.  Insert each element into `diag[r+c]`.
3.  Reverse even diagonals and flatten.
----------

### 🔹 Pseudocode

```
for r in 0..m-1:
    for c in 0..n-1:
        diag[r+c].add(mat[r][c])

for i in 0..m+n-2:
    if i even: reverse(diag[i])
    append diag[i] to result

```

----------

### 🔹 C++ Code

```cpp
class Solution 
{
	public:
    vector<int> findDiagonalOrder(vector<vector<int>>& mat) 
    {
        int m = mat.size(), n = mat[0].size();
        vector<vector<int>> diag(m + n - 1);
        
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                diag[r + c].push_back(mat[r][c]);
            }
        }

        vector<int> result;
        result.reserve(m * n);

        for (int i = 0; i < m + n - 1; i++) 
        {
            if (i % 2 == 0) reverse(diag[i].begin(), diag[i].end());
            result.insert(result.end(), diag[i].begin(), diag[i].end());
        }
        return result;
    }
};

```

----------
### 🔹 Complexity
-   **Time:** `O(m*n)`
-   **Space:** `O(m*n)` (extra for diagonals)
----------

### 🔹 Suggestion
⚠️ Easy to understand but **not memory-efficient**.  
Good for teaching beginners or if you need diagonal grouping for later use.

----------

## 🔥 Method 4: Pointer Simulation (Move Like a Person Walking)

### 🔹 Idea
Simulate traversal:
-   Start `(r=0,c=0)` with `dir=1` (up-right).    
-   Move in current direction.    
-   Change direction when you hit **top/bottom/left/right** border.    
----------

### 🔹 Algorithm

1.  Start at `(0,0)`, direction = up-right.   
2.  Add element, move `(r--,c++)` or `(r++,c--)`.    
3.  When you cross boundary, adjust `r,c` and switch direction.
    
   ----------

### 🔹 Pseudocode
```
r=0,c=0,dir=1
while not visited all:
    push mat[r][c]
    if dir==1:
        if c==n-1: r++, dir=-1
        else if r==0: c++, dir=-1
        else: r--, c++
    else:
        if r==m-1: c++, dir=1
        else if c==0: r++, dir=1
        else: r++, c--
```
----------
### 🔹 C++ Code

```cpp
class Solution 
{
	public:
    vector<int> findDiagonalOrder(vector<vector<int>>& mat) 
    {
        if (mat.empty()) return {};
        int m = mat.size(), n = mat[0].size();
        vector<int> result;
        result.reserve(m * n);

        int r = 0, c = 0, dir = 1; 

        while (result.size() < m * n) 
        {
            result.push_back(mat[r][c]);
            if (dir == 1) { // up-right
                if (c == n - 1) { r++; dir = -1; }
                else if (r == 0) { c++; dir = -1; }
                else { r--; c++; }
            } 
            else 
            { // down-left
                if (r == m - 1) { c++; dir = 1; }
                else if (c == 0) { r++; dir = 1; }
                else { r++; c--; }
            }
        }
        return result;
    }
};

```
----------

### 🔹 Complexity
-   **Time:** `O(m*n)`
-   **Space:** `O(1)` extra
----------
### 🔹 Suggestion
⚠️ Intuitive, like “walking” the matrix, but **harder to debug** due to many boundary cases.  
Best for **visual learners**.
