
## [679. 24 Game](https://leetcode.com/problems/24-game/)
You are given an integer array  `cards`  of length  `4`. You have four cards, each containing a number in the range  `[1, 9]`. You should arrange the numbers on these cards in a mathematical expression using the operators  `['+', '-', '*', '/']`  and the parentheses  `'('`  and  `')'`  to get the value 24.

You are restricted with the following rules:

-   The division operator  `'/'`  represents real division, not integer division.
    -   For example,  `4 / (1 - 2 / 3) = 4 / (1 / 3) = 12`.
-   Every operation done is between two numbers. In particular, we cannot use  `'-'`  as a unary operator.
    -   For example, if  `cards = [1, 1, 1, 1]`, the expression  `"-1 - 1 - 1 - 1"`  is  **not allowed**.
-   You cannot concatenate numbers together
    -   For example, if  `cards = [1, 2, 1, 2]`, the expression  `"12 + 12"`  is not valid.

Return  `true`  if you can get such expression that evaluates to  `24`, and  `false`  otherwise.

**Example 1:**

**Input:** cards = [4,1,8,7]
**Output:** true
**Explanation:** (8-4) * (7-1) = 24

**Example 2:**

**Input:** cards = [1,2,1,2]
**Output:** false

**Constraints:**

-   `cards.length == 4`
-   `1 <= cards[i] <= 9`

## **Brute force recursive + backtracking solution**:
```cpp
class  Solution 
{
	public:
	bool  judgePoint24(vector<int>&  cards) 
	{
		vector<double> nums(cards.begin(), cards.end());
		return  solve(nums);
	}

	private:
	bool  solve(vector<double> nums) 
	{
	if (nums.size() == 1) 
	{
			return  fabs(nums[0] - 24.0) < 1e-6;
	}

	for (int i = 0; i < nums.size(); i++) 
	{
		for (int j = 0; j < nums.size(); j++) 
		{
			if (i == j) continue;
			vector<double> next;
			for (int k = 0; k < nums.size(); k++) 
			{
				if (k != i && k != j) next.push_back(nums[k]);
			}
			
			for (double val : compute(nums[i], nums[j])) 
			{
				next.push_back(val);
				if (solve(next)) return  true;
				next.pop_back();
			}
		}
	}

	return  false;
	}

vector<double> compute(double  a, double  b) 
{
	vector<double> res;
	res.push_back(a + b);
	res.push_back(a - b);
	res.push_back(b - a);
	res.push_back(a * b);
	if (fabs(b) > 1e-6) res.push_back(a / b);
	if (fabs(a) > 1e-6) res.push_back(b / a);
	return res;
}
};
```
## ðŸ”¹ Approach (Step by Step)

### Step 1: Convert input to floating-point numbers

`vector<double> nums(cards.begin(), cards.end());` 

-   Since division is involved, integers are converted to `double` for accurate results.
 
----------

### Step 2: Recursive function (`solve`)

-   The function tries all possible **pair selections** and **operations** recursively until only one number remains.
    
-   If that final number â‰ˆ 24 â†’ return `true`.
    
----------

### Step 3: Base Case
```cpp
if (nums.size() == 1) { return  fabs(nums[0] - 24.0) < 1e-6; 
}
```
-   When only **one number is left**, check if it is **close enough to 24** (considering floating-point precision).
    
----------

### Step 4: Try all pairs of numbers
```cpp
for (int i = 0; i < nums.size(); i++) 
{ 
	for (int j = 0; j < nums.size(); j++) 
	{ 
		if (i == j) continue; 
```
-   Pick two different numbers `(i, j)` from the list.
    
-   Example: if `nums = [4, 1, 8, 7]`, choose `(4, 7)`.
    
----------

### Step 5: Create new list without chosen pair
```cpp
vector<double> next; 
for (int k = 0; k < nums.size(); k++) 
{ 
	if (k != i && k != j) next.push_back(nums[k]);
}
```
-   Remove `i` and `j` from the list.
    
-   Example: If `(4, 7)` chosen â†’ new list = `[1, 8]`.
    

----------

### Step 6: Apply all possible operations
```cpp
for (double val : compute(nums[i], nums[j])) 
{
    next.push_back(val); if (solve(next)) return  true;
    next.pop_back();
}
```
-   Call `compute(a, b)` which returns results of:
    
    -   `a + b`
        
    -   `a - b`
        
    -   `b - a`
        
    -   `a * b`
        
    -   `a / b` (if `b != 0`)
        
    -   `b / a` (if `a != 0`)
        
-   Each result is added back into `next`, and recursion is applied.
    
-   If **any branch** reaches 24 â†’ immediately return `true`.
    

----------

### Step 7: Backtracking

`next.pop_back();` 

-   Remove last pushed result to explore other operations.
    

----------

### Step 8: If no combination works

`return  false;` 

-   If none of the possibilities yield 24, return false.
