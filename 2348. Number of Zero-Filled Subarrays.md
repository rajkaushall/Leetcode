
## [2348. Number of Zero-Filled Subarrays](https://leetcode.com/problems/number-of-zero-filled-subarrays/)
Given an integer array  `nums`, return  _the number of  **subarrays**  filled with_ `0`.

A  **subarray**  is a contiguous non-empty sequence of elements within an array.

**Example 1:**

**Input:** nums = [1,3,0,0,2,0,0,4]
**Output:** 6
**Explanation:** 
There are 4 occurrences of [0] as a subarray.
There are 2 occurrences of [0,0] as a subarray.
There is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6.

**Example 2:**

**Input:** nums = [0,0,0,2,0,0]
**Output:** 9
**Explanation:** There are 5 occurrences of [0] as a subarray.
There are 3 occurrences of [0,0] as a subarray.
There is 1 occurrence of [0,0,0] as a subarray.
There is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.

**Example 3:**

**Input:** nums = [2,10,2019]
**Output:** 0
**Explanation:** There is no subarray filled with 0. Therefore, we return 0.

**Constraints:**

-   `1 <= nums.length <= 105`
-   `-109 <= nums[i] <= 109`

## **1. Brute Force (Triple Loop)**

**Idea:** Check every subarray explicitly, and verify if all elements are zero.

**Steps:**
1.  Generate all subarrays using two loops `(i, j)`.
2.  For each subarray, use another loop to check if all elements are zero.  
3.  If yes → increment count.

```cpp
class Solution 
{
	public:
    long long zeroFilledSubarray(vector<int>& nums) 
    {
        long long ans = 0;
        int n = nums.size();
        for (int i = 0; i < n; i++) 
        {
            for (int j = i; j < n; j++) 
            {
                bool allZero = true;
                for (int k = i; k <= j; k++) 
                {
                    if (nums[k] != 0) 
                    {
                        allZero = false;
                        break;
                    }
                }
                if (allZero) ans++;
            }
        }
        return ans;
    }
};
```
**Complexity:**
-   Time: **O(n³)**    
-   Space: **O(1)**

---
## **2. Improved Brute Force (Double Loop)**

**Idea:** Instead of checking all elements again, extend subarray while maintaining "all zero" property.
**Steps:**
1.  Fix start `i`. 
2.  Expand subarray `j = i … n-1`. 
3.  Stop if a non-zero appears.
4.  Count valid subarrays along the way.

```cpp
class Solution 
{
	public:
    long long zeroFilledSubarray(vector<int>& nums) 
    {
        long long ans = 0;
        int n = nums.size();
        for (int i = 0; i < n; i++) 
        {
            for (int j = i; j < n; j++) 
            {
                if (nums[j] == 0) ans++;
                else break;
            }
        }
        return ans;
    }
};
```

**Complexity:**
-   Time: **O(n²)** 
-   Space: **O(1)**
    

----------

## **3. Running Count (Incremental Method)**
**Idea:** Maintain a running count of consecutive zeros.
-   Each time we see `0`, it adds new subarrays ending at that index.
**Steps:**
1.  Initialize `count = 0, ans = 0`.  
2.  Traverse array:
    -   If element is `0`: `count++`, add `count` to `ans`.  
    -   If non-zero: reset `count = 0`.
        

```cpp
class Solution 
{
	public:
    long long zeroFilledSubarray(vector<int>& nums) 
    {
        long long ans = 0, count = 0;
        for (int x : nums) 
        {
            if (x == 0) 
            {
                count++;
                ans += count;
            } 
            else 
            {
                count = 0;
            }
        }
        return ans;
    }
};
 ```

**Complexity:**

-   Time: **O(n)**
    
-   Space: **O(1)**
    

----------

## **4. Block Counting (Mathematical Formula)**
**Idea:** Each continuous block of zeros contributes: **k∗(k+1)/2**
where `k` = length of zero block.

**Steps:**
1.  Traverse array and count length of consecutive zeros.
2.  When non-zero or array ends:
    -   Add `k*(k+1)/2` to `ans`. 
    -   Reset `k = 0`.
        

**Code:**
```cpp
class Solution 
{
	public:
    long long zeroFilledSubarray(vector<int>& nums) 
    {
        long long ans = 0;
        long long len = 0;
        for (int x : nums) 
        {
            if (x == 0) len++;
            else 
            {
                ans += (len * (len + 1)) / 2;
                len = 0;
            }
        }
        ans += (len * (len + 1)) / 2; // last block
        return ans;
    }
};
```

**Complexity:**

-   Time: **O(n)**
    
-   Space: **O(1)**
    

----------

## **5. Stack-based Simulation** (Not practical but unique)
**Idea:** Use stack to simulate running consecutive zero lengths.
**Steps:**
1.  Traverse array.
2.  Push `0` when non-zero appears.
3.  For zeros, increment top of stack and push new values.
4.  Count using stack size.
    

```cpp
class Solution {
public:
    long long zeroFilledSubarray(vector<int>& nums) {
        stack<int> st;
        long long ans = 0;
        int count = 0;
        for (int x : nums) {
            if (x == 0) {
                count++;
                st.push(count);
                ans += count;
            } else {
                count = 0;
                while (!st.empty()) st.pop();
            }
        }
        return ans;
    }
};
```

**Complexity:**
-   Time: **O(n)** (push/pop each element once)
-   Space: **O(n)**
