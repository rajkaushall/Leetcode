
## [1493. Longest Subarray of 1's After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/)
Return  _the size of the longest non-empty subarray containing only_ `1`_'s in the resulting array_. Return  `0`  if there is no such subarray.

**Example 1:**
**Input:** nums = [1,1,0,1]
**Output:** 3
**Explanation:** After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.

**Example 2:**
**Input:** nums = [0,1,1,1,0,1,1,0,1]
**Output:** 5
**Explanation:** After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].

**Example 3:**
**Input:** nums = [1,1,1]
**Output:** 2
**Explanation:** You must delete one element.

**Constraints:**
-   `1 <= nums.length <= 105`
-   `nums[i]`  is either  `0`  or  `1`

---
## üõ†Ô∏è **Approach 1: Brute Force ( O ( n¬≤ ) )**
### Idea:
Try deleting each element one by one, then calculate the longest consecutive `1`s in the modified array.

### Steps:
1.  Loop through each index `i` as the deleted element.    
2.  Create a new array excluding element `i`. 
3.  Count max consecutive `1`s.    
4.  Track the max length across all deletions.
   
----------
### Pseudo-code:
```
function longestSubarray(nums):
    n = length of nums
    ans = 0

    for i from 0 to n-1:           // choose element to delete
        count = 0
        maxCount = 0

        for j from 0 to n-1:       // scan entire array
            if j == i: 
                continue           // skip deleted element
            
            if nums[j] == 1:
                count = count + 1
                maxCount = max(maxCount, count)
            else:
                count = 0

        ans = max(ans, maxCount)

    return ans
```
----------

### C++ Code:
```cpp
class Solution {
public:
    int longestSubarray(vector<int>& nums) 
    {
        int n = nums.size();
        int ans = 0;
        for (int i = 0; i < n; i++) 
        {
            int count = 0, maxCount = 0;
            for (int j = 0; j < n; j++) {
                if (j == i) continue; // skip deleted element
                if (nums[j] == 1) 
                {
                    count++;
                    maxCount = max(maxCount, count);
                } 
                else 
                {
                    count = 0;
                }
            }
            ans = max(ans, maxCount);
        }
        return ans;
    }
};

```
‚è≥ **Time Complexity:** O ( n¬≤ )  
üíæ **Space Complexity:** O ( 1 )

----------

## üõ†Ô∏è **Approach 2: Prefix & Suffix Arrays ( O ( n ) )**

### Idea:
Use prefix and suffix arrays to count consecutive `1`s to the left and right of each index. Deleting index `i` gives `prefix[i-1] + suffix[i+1]`.

----------
### Steps:
1.  Compute `prefix[i]`: count of consecutive `1`s ending at `i`.    
2.  Compute `suffix[i]`: count of consecutive `1`s starting at `i`.  
3.  For each `i`, `maxLen = max(maxLen, prefix[i-1] + suffix[i+1])`.    
4.  Handle edge cases if all are `1`s.
    

----------
### Pseudo-code:
```
function longestSubarray(nums):
    n = length of nums
    prefix[n], suffix[n]

    // Compute prefix array
    for i from 0 to n-1:
        if nums[i] == 1:
            if i > 0: prefix[i] = prefix[i-1] + 1
            else: prefix[i] = 1
        else:
            prefix[i] = 0

    // Compute suffix array
    for i from n-1 down to 0:
        if nums[i] == 1:
            if i < n-1: suffix[i] = suffix[i+1] + 1
            else: suffix[i] = 1
        else:
            suffix[i] = 0

    ans = 0
    for i from 0 to n-1:
        left = (i > 0) ? prefix[i-1] : 0
        right = (i < n-1) ? suffix[i+1] : 0
        ans = max(ans, left + right)

    return ans
```

----------

### C++ Code:
```cpp
class Solution 
{
	public:
    int longestSubarray(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int> prefix(n, 0), suffix(n, 0);

        for (int i = 0; i < n; i++) 
            prefix[i] = (nums[i] == 1) ? (i > 0 ? prefix[i-1] : 0) + 1 : 0;

        for (int i = n-1; i >= 0; i--) 
            suffix[i] = (nums[i] == 1) ? (i < n-1 ? suffix[i+1] : 0) + 1 : 0;

        int ans = 0;
        for (int i = 0; i < n; i++) 
        {
            int left = (i > 0) ? prefix[i-1] : 0;
            int right = (i < n-1) ? suffix[i+1] : 0;
            ans = max(ans, left + right);
        }
        return ans;
    }
};

```
‚è≥ **Time Complexity:** O ( n )  
üíæ **Space Complexity:** O ( n )

----------

## üõ†Ô∏è **Approach 3: Sliding Window ( Optimal O ( n ) )**

### Idea:

Maintain a window with **at most one `0`**. This effectively simulates deleting one element.

----------
### Steps:
1.  Initialize two pointers `start` and `end`.    
2.  Keep track of count of zeros in the window.    
3.  Expand `end`; if `zeros > 1`, move `start`.    
4.  The length is always `end - start` (because one `0` is "deleted").    
5.  Return max length.
----------
### Pseudo-code:
```
function longestSubarray(nums):
    start = 0
    zeros = 0
    ans = 0

    for end from 0 to n-1:
        if nums[end] == 0:
            zeros++

        while zeros > 1:
            if nums[start] == 0:
                zeros--
            start++

        ans = max(ans, end - start)

    return ans
```

----------

### C++ Code:
```cpp
class Solution 
{
	public:
    int longestSubarray(vector<int>& nums) 
    {
        int start = 0, zeros = 0, ans = 0;
        for (int end = 0; end < nums.size(); end++) 
        {
            if (nums[end] == 0) zeros++;
            while (zeros > 1) 
            {
                if (nums[start] == 0) zeros--;
                start++;
            }
            ans = max(ans, end - start);
        }
        return ans;
    }
};
```

‚è≥ **Time Complexity:** O ( n )  
üíæ **Space Complexity:** O ( 1 )

----------

## üõ†Ô∏è **Approach 4: Counting Segments of 1's (Alternative O ( n ) )**

### Idea:
Track consecutive segments of `1`s and combine them if separated by a single `0`.

----------
### Steps:
1.  Iterate through array, track lengths of consecutive `1`s.   
2.  When a `0` is found, combine left and right segments if only one `0` between them.    
3.  Keep max.
----------
### Pseudo Code
```
function longestSubarray(nums):
    prev = 0         // length of 1's before last zero
    curr = 0         // current streak of 1's
    ans = 0

    for each element x in nums:
        if x == 1:
            curr++
        else:
            ans = max(ans, prev + curr)
            prev = curr
            curr = 0

    ans = max(ans, prev + curr)

    if ans == length of nums:    // if all are 1's
        return ans - 1           // must delete one
    else:
        return ans
```

### C++ Code:
```cpp
class Solution 
{
	public:
    int longestSubarray(vector<int>& nums) 
    {
        int prev = 0, curr = 0, ans = 0;
        for (int n : nums) 
        {
            if (n == 1) 
            {
                curr++;
            } 
            else 
            {
                ans = max(ans, prev + curr);
                prev = curr;
                curr = 0;
            }
        }
        ans = max(ans, prev + curr);
        return (ans == nums.size()) ? ans - 1 : ans; 
    }
};

```

‚è≥ **Time Complexity:** O ( n )  
üíæ **Space Complexity:** O ( 1 )

----------

## üî• Best Approach

-   **Sliding Window (Approach 3)** is **cleanest & most optimal**: `O(n)` time, `O(1)` space.
    
-   **Prefix-Suffix (Approach 2)** is also easy to understand.
