
## [326. Power of Three](https://leetcode.com/problems/power-of-three/)

Given an integer  `n`, return  _`true`  if it is a power of three. Otherwise, return  `false`_.
An integer  `n`  is a power of three, if there exists an integer  `x`  such that  `n == 3x`.

**Example 1:**

**Input:** n = 27
**Output:** true
**Explanation:** 27 = 33

**Example 2:**

**Input:** n = 0
**Output:** false
**Explanation:** There is no x where 3x = 0.

**Example 3:**

**Input:** n = -1
**Output:** false
**Explanation:** There is no x where 3x = (-1).

**Constraints:**

-   `-231 <= n <= 231 - 1`

## Approaches:

### 1Ô∏è‚É£ Iterative Division Method
``` cpp
class Solution {
public:
    bool isPowerOfThree(int n) {
        if (n <= 0) return false;
        while (n % 3 == 0) {
            n /= 3;
        }
        return n == 1;
    }
};
```

**Steps:**

1.  Agar `n <= 0` hai ‚Üí directly return false.
    
2.  Jab tak `n % 3 == 0` hai, `n` ko 3 se divide karo.
    
3.  Agar last me `n == 1` hai ‚Üí true else false.
    

**Time Complexity:** O(log‚ÇÉn)  
**Space Complexity:** O(1) (no extra memory)




### 2Ô∏è‚É£ Recursive Method
``` cpp
class Solution {
public:
    bool isPowerOfThree(int n) {
        if (n == 1) return true;          // base case
        if (n <= 0 || n % 3 != 0) return false; 
        return isPowerOfThree(n / 3);     // recursion step
    }
};
```
**Steps:**

1.  Base case: Agar `n == 1` ‚Üí true.
    
2.  Agar `n <= 0` ya `n % 3 != 0` ‚Üí false.
    
3.  Otherwise, recursion call karo `n / 3` ke saath.
    

**Time Complexity:** O(log‚ÇÉn)  
**Space Complexity:** O(log‚ÇÉn) (recursion stack memory)




### 3Ô∏è‚É£ Logarithmic Method
``` cpp
#include <cmath>
class Solution {
public:
    bool isPowerOfThree(int n) {
        if (n <= 0) return false;
        double val = log10(n) / log10(3); // log‚ÇÉ(n)
        return fabs(val - round(val)) < 1e-10; // check near integer
    }
};
```
**Steps:**

1.  Agar `n <= 0` ‚Üí false.
    
2.  `val = log‚ÇÉ(n)` calculate karo using change-of-base formula: `log10(n)/log10(3)`.
    
3.  Agar `val` ek integer ke bahut close hai ‚Üí true else false.
    

**Time Complexity:** O(1)  
**Space Complexity:** O(1)  
‚ö† Floating-point precision issues ka dhyan rakho.




### 4Ô∏è‚É£ Max Power of 3 Trick (Fastest)
``` cpp
class Solution {
public:
    bool isPowerOfThree(int n) {
        // largest power of 3 in 32-bit int = 1162261467 (3^19)
        return n > 0 && 1162261467 % n == 0;
    }
};
```
**Steps:**

1.  32-bit integer me highest power of 3 precompute kiya: `3^19 = 1162261467`.
    
2.  Agar yeh number `n` se perfectly divisible hai ‚Üí `n` power of 3 hai.
    

**Time Complexity:** O(1)  
**Space Complexity:** O(1)  
üí® Super fast (no loop, no recursion, no log).




### 5Ô∏è‚É£ Precomputation Method
```cpp
#include <unordered_set>
class Solution {
public:
    bool isPowerOfThree(int n) {
        static std::unordered_set<int> powers = {
            1, 3, 9, 27, 81, 243, 729, 2187, 
            6561, 19683, 59049, 177147, 
            531441, 1594323, 4782969, 
            14348907, 43046721, 129140163, 
            387420489, 1162261467
        };
        return powers.count(n) > 0;
    }
};
```
**Steps:**

1.  Ek `unordered_set` banate hai jisme saare powers of 3 store hain.
    
2.  Check karo ki `n` set me hai ya nahi.
    

**Time Complexity:** O(1) (hash lookup)  
**Space Complexity:** O(1) (static memory for set)
