
## [277. Count Square Submatrices with All Ones](https://leetcode.com/problems/count-square-submatrices-with-all-ones/)
Given a  `m * n`  matrix of ones and zeros, return how many  **square**  submatrices have all ones.

**Example 1:**

**Input:** matrix =
[
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
**Output:** 15
**Explanation:** 
There are **10** squares of side 1.
There are **4** squares of side 2.
There is  **1** square of side 3.
Total number of squares = 10 + 4 + 1 = **15**.

**Example 2:**

**Input:** matrix = 
[
  [1,0,1],
  [1,1,0],
  [1,1,0]
]
**Output:** 7
**Explanation:** 
There are **6** squares of side 1.  
There is **1** square of side 2. 
Total number of squares = 6 + 1 = **7**.

**Constraints:**

-   `1 <= arr.length <= 300`
-   `1 <= arr[0].length <= 300`
-   `0 <= arr[i][j] <= 1`
---
### ✅ Method 1: Brute Force (Check all possible squares)
### 💡 Idea
-   Har cell `(i, j)` ko top-left corner maano.
-   Try karo 1×1, 2×2, 3×3 ... squares until matrix ke andar ho.
-   Har square ke liye verify karo ki saare cells `1` hain.
    

### 🪜 Steps

1.  Iterate over all `(i,j)`.
2.  For each, expand square size `k`.
3.  Check if all elements in that `k×k` square are 1.
4.  Count valid ones.
    

### ⏳ Complexity
-   **Time:** O(m * n * min(m,n)^2) (har square ke liye har cell check karna).
-   **Space:** O(1).
    

### 💻 Code
```cpp
class Solution 
{
	public:
    int countSquares(vector<vector<int>>& matrix) 
    {
        int m = matrix.size();
        int n = matrix[0].size();
        int total = 0;

        for (int i = 0; i < m; i++) 
        {
            for (int j = 0; j < n; j++) 
            {
                int maxSize = min(m - i, n - j);
                for (int size = 1; size <= maxSize; size++) 
                {
                    bool valid = true;
                    for (int x = i; x < i + size; x++) 
                    {
                        for (int y = j; y < j + size; y++) 
                        {
                            if (matrix[x][y] == 0) 
                            {
                                valid = false;
                                break;
                            }
                        }
                        if (!valid) break;
                    }
                    if (valid) total++;
                    else break; // no need to try bigger square
                }
            }
        }
        return total;
    }
};
```

### ✅ Method 2: Better Brute Force with Prefix Sum

### 💡 Idea
Instead of checking all cells in submatrix repeatedly, use **2D prefix sum** to quickly check if submatrix sum == area.

### 🪜 Steps
1.  Compute prefix sum `pre[i][j]`.
2.  For each `(i, j)` and square size `k`, get submatrix sum in O(1).   
3.  If sum == k*k → all ones.
    

### ⏳ Complexity
-   **Time:** O(m * n * min(m,n)^2) (squares check), but each check O(1).
-   **Space:** O(m * n).
    

### 💻 Code
```cpp
class Solution 
{
	public:
    int countSquares(vector<vector<int>>& matrix) 
    {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<vector<int>> pre(m+1, vector<int>(n+1, 0));

        // Build prefix sum
        for (int i = 1; i <= m; i++) 
        {
            for (int j = 1; j <= n; j++) 
            {
                pre[i][j] = matrix[i-1][j-1] + pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1];
            }
        }

        int total = 0;
        for (int i = 0; i < m; i++) 
        {
            for (int j = 0; j < n; j++) 
            {
                int maxSize = min(m - i, n - j);
                for (int size = 1; size <= maxSize; size++) 
                {
                    int x1 = i, y1 = j;
                    int x2 = i + size - 1, y2 = j + size - 1;
                    int sum = pre[x2+1][y2+1] - pre[x1][y2+1] - pre[x2+1][y1] + pre[x1][y1];
                    if (sum == size*size) total++;
                    else break;
                }
            }
        }
        return total;
    }
};
```

### ✅ Method 3: Dynamic Programming (Optimized)

### 💡 Idea
-   `dp[i][j]` = side length of the largest square with bottom-right corner at `(i,j)`.
-   Transition:
    
```python
if matrix[i][j] == 1:
    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
else:
    dp[i][j] = 0

```
    
-   Each `dp[i][j]` contributes to answer (because if `dp[i][j] = k`, then there are `k` squares ending at `(i,j)`).
    

### 🪜 Steps

1.  Initialize `dp` same size as matrix.
2.  First row/col = matrix values (since only 1×1 possible).
3.  Apply formula for others.
4.  Sum all `dp[i][j]`.
    

### ⏳ Complexity
-   **Time:** O(m * n).
-   **Space:** O(m * n) → can be optimized to O(n).
    

### 💻 Code
```cpp
class Solution 
{
	public:
    int countSquares(vector<vector<int>>& matrix) 
    {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        int total = 0;

        for (int i = 0; i < m; i++) 
        {
            for (int j = 0; j < n; j++) 
            {
                if (matrix[i][j] == 1) 
                {
                    if (i == 0 || j == 0) dp[i][j] = 1;
                    else dp[i][j] = 1 + min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});
                    total += dp[i][j];
                }
            }
        }
        return total;
    }
};
```

### ✅ Method 4: Space Optimized DP

### 💡 Idea
Since `dp[i][j]` depends only on previous row + previous column + diagonal, we don’t need full matrix, just **two rows**.

### ⏳ Complexity
-   **Time:** O(m * n).
-   **Space:** O(n).
    

### 💻 Code
``` cpp
class Solution 
{
	public:
    int countSquares(vector<vector<int>>& matrix) 
    {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<int> prev(n, 0), curr(n, 0);
        int total = 0;

        for (int i = 0; i < m; i++) 
        {
            for (int j = 0; j < n; j++) 
            {
                if (matrix[i][j] == 1) 
                {
                    if (i == 0 || j == 0) curr[j] = 1;
                    else curr[j] = 1 + min({prev[j], curr[j-1], prev[j-1]});
                    total += curr[j];
                } 
                else 
                {
                    curr[j] = 0;
                }
            }
            prev = curr;
        }
        return total;
    }
};

```
