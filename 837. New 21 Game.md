
# [837. New 21 Game](https://leetcode.com/problems/new-21-game/)
Alice plays the following game, loosely based on the card game  **"21"**.

Alice starts with  `0`  points and draws numbers while she has less than  `k`  points. During each draw, she gains an integer number of points randomly from the range  `[1, maxPts]`, where  `maxPts`  is an integer. Each draw is independent and the outcomes have equal probabilities.

Alice stops drawing numbers when she gets  `k`  **or more points**.

Return the probability that Alice has  `n`  or fewer points.

Answers within  `10-5`  of the actual answer are considered accepted.

**Example 1:**

**Input:** n = 10, k = 1, maxPts = 10
**Output:** 1.00000
**Explanation:** Alice gets a single card, then stops.

**Example 2:**

**Input:** n = 6, k = 1, maxPts = 10
**Output:** 0.60000
**Explanation:** Alice gets a single card, then stops.
In 6 out of 10 possibilities, she is at or below 6 points.

**Example 3:**

**Input:** n = 21, k = 17, maxPts = 10
**Output:** 0.73278

**Constraints:**

-   `0 <= k <= n <= 104`
-   `1 <= maxPts <= 104`
----
## ðŸ”¹ DP Idea

Letâ€™s define:

-   `dp[x]` = Probability that **final score = x**.
    
-   Answer = **sum(dp[i]) for k â‰¤ i â‰¤ n**.
    

**Transition:**

-   Agar Alice at state `j < k` hai, wo ek card draw karti hai (1â€¦maxPts).
    
-   Uske baad wo reach karegi `j + p` (where `1 â‰¤ p â‰¤ maxPts`).
    
-   So:   dp[i] = (dp[iâˆ’1]+dp[iâˆ’2]+...+dp[iâˆ’maxPts]) / maxPts , (only from j < k)

----------

## ðŸ”¹ Sliding Window Optimization

-   Har `dp[i]` ko calculate karte waqt humko pichhle **maxPts values** ka sum chahiye.
    
-   Isko maintain karne ke liye ek **sliding window sum** rakhte hain.
    

----------

## ðŸ”¹ Optimized Code (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    double new21Game(int n, int k, int maxPts) {
        if (k == 0 || n >= k - 1 + maxPts) return 1.0;

        vector<double> dp(n + 1, 0.0);
        dp[0] = 1.0;

        double windowSum = 1.0;  // sum of last maxPts valid dp
        double result = 0.0;

        for (int i = 1; i <= n; i++) {
            dp[i] = windowSum / maxPts;

            if (i < k) {
                windowSum += dp[i];  // can still draw more
            } else {
                result += dp[i];     // game stops
            }

            if (i - maxPts >= 0) {
                windowSum -= dp[i - maxPts];
            }
        }

        return result;
    }
};
```
## ðŸ”¹ Complexity

-   **Time:** O(n) (har state ek hi baar compute hota hai)
    
-   **Space:** O(n) (dp array) â€” agar chaho to O(maxPts) tak optimize kar sakte ho.
