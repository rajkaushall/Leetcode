
# Ways to Express an Integer as Sum of Powers

**LeetCode Problem 2787 ‚Äî Medium**

## üìú Problem Statement

Given two positive integers `n` and `x`, find the number of ways `n` can be expressed as the sum of distinct positive integers, each raised to the `x`th power.  
That is, find the number of sets of unique integers `[n‚ÇÅ, n‚ÇÇ, ..., n‚Çñ]` such that:
$$
n = n_1^x + n_2^x + ... + n_k^x
$$

Return the result modulo $10^9 + 7$.

---
## üí° Example

### Example 1
**Input:**
n = 10, x = 2

**Output:**
1

**Explanation:**
- Only one way:  
  $n = 3^2 + 1^2 = 9 + 1 = 10$

---

### Example 2
**Input:**
n = 4, x = 1
**Output:**
2

**Explanation:**
- $4^1 = 4$
- $3^1 + 1^1 = 3 + 1 = 4$
----
## üìå Constraints
- $1 \leq n \leq 300$
- $1 \leq x \leq 5$
---
## Possible Approaches:
-   **Pure Recursion (Backtracking)** ‚Üí simplest, but slow.
-   **Recursion + Memoization (Top-down DP)** ‚Üí optimal for constraints.
-   **Bottom-up DP (0/1 Knapsack style)** ‚Üí iterative table-based.
-   **Space-optimized Bottom-up DP** ‚Üí improved memory.





## 1Ô∏è‚É£ Pure Recursion (Backtracking)
### **Algorithm Steps:**
**Goal:** Count the number of ways to represent `n` as a sum of unique integers raised to the power `x`.

1.  **Start recursion from `num = 1`** with the remaining sum = `n`.
2.  **Base Cases**:
    -   If `remaining == 0` ‚Üí a valid combination is found, return 1.
    -   If `pow(num, x) > remaining` ‚Üí cannot include this number (or any larger one), return 0.
3.  **Recursive Choices**:
    -   **Include current number**:  
        Subtract `pow(num, x)` from `remaining`, move to `num + 1`, and recurse.
    -   **Exclude current number**:  
        Keep `remaining` unchanged, move to `num + 1`, and recurse.
4.  **Sum both choices** modulo `1e9 + 7`.
5.  **Final Answer**:  
    Call `dfs(1, n, x)` and return the result.
---------
## **Time Complexity Analysis**
-   At each number `num`, there are **two choices**: include or exclude.
-   The maximum `num` considered is around `n^(1/x)` (since `num^x ‚â§ n`). 
-   In the worst case, recursion explores almost all subsets of numbers from `1` to n<sup>1/x 
    
-   **Time Complexity:**  O(2<sup>n<sup>1/x</sup>)
    
    This is **exponential** without memoization.
----------
## **Space Complexity Analysis**

-   **Recursive stack depth:** At most `n^(1/x)` calls deep.
-   **Without memoization:**  O(n<sup>1/x )

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
    const int MOD = 1e9+7;
public:
    int dfs(int num, int remaining, int x) {
        if (remaining == 0) return 1;
        if (pow(num, x) > remaining) return 0;

        int ways = 0;

        // Include current number
        ways = (ways + dfs(num+1, remaining - pow(num, x), x)) % MOD;

        // Exclude current number
        ways = (ways + dfs(num+1, remaining, x)) % MOD;

        return ways;
    }

    int numberOfWays(int n, int x) {
        return dfs(1, n, x);
    }
};  
```



## 2Ô∏è‚É£ Recursion + Memoization (Top-down DP)
### **Algorithm Steps:**
**Goal:** Count the number of ways to represent `n` as a sum of **unique integers** raised to the power `x`, using memoization to avoid recomputation.

1.  **Initialize a DP table** `dp` of size `(n+2) √ó (n+1)` with `-1`.
    -   `dp[num][remaining]` stores the number of ways to form `remaining` using numbers starting from `num`.  
2.  **Start DFS from `num = 1`** and `remaining = n`.
3.  **Base Cases**:
    -   If `remaining == 0` ‚Üí A valid combination is found ‚Üí return 1.
    -   If `pow(num, x) > remaining` ‚Üí No further numbers can be used ‚Üí return 0.
4.  **Check memoization**:
    -   If `dp[num][remaining] != -1` ‚Üí return stored value (avoid recomputation). 
5.  **Recursive Steps**:
    -   **Include current number**: Subtract `pow(num, x)` from `remaining` and move to `num + 1`.  
    -   **Exclude current number**: Keep `remaining` unchanged and move to `num + 1`.
6.  **Store result in `dp[num][remaining]`** and return it modulo `1e9 + 
7.  **Return the result** from `numberOfWays(n, x)`.

----------

## **Time Complexity**
-   The DP state is `(num, remaining)`:
    -   `num` can go up to `n^(1/x)` approximately.
    -   `remaining` can go from `0` to `n`.
-   Each state is computed **once**, and each computation takes **O(1)** work.

-   **Time Complexity:** O(n.n<sup>1/x</sup>)

Where:
-   `n` = target sum
-   `n^{1/x}` ‚âà maximum base number to consider
----------
## **Space Complexity**
-   **DP table:** `(n+2) √ó (n+1)` ‚Üí O(n.n<sup>1/x</sup>)

-   **Recursion stack depth:** at most `n^{1/x}`.
    
-   **Total Space:** O(n.n<sup>1/x</sup> + n<sup>1/x)

which is dominated by O(n.n<sup>1/x</sup>)

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
    const int MOD = 1e9+7;
    vector<vector<int>> dp;
public:
    int dfs(int num, int remaining, int x) {
        if (remaining == 0) return 1;
        if (pow(num, x) > remaining) return 0;
        if (dp[num][remaining] != -1) return dp[num][remaining];

        long long ways = 0;

        // Include
        ways = (ways + dfs(num+1, remaining - pow(num, x), x)) % MOD;

        // Exclude
        ways = (ways + dfs(num+1, remaining, x)) % MOD;

        return dp[num][remaining] = ways;
    }

    int numberOfWays(int n, int x) {
        dp.assign(n+2, vector<int>(n+1, -1));
        return dfs(1, n, x);
    }
};
```



## 3Ô∏è‚É£ Bottom-up DP (0/1 Knapsack style)
## **Idea**
The problem is to count the number of ways to express `n` as the sum of **unique integers raised to the power `x`**.  
Instead of recursion, we use **bottom-up dynamic programming** to avoid stack overhead and redundant calculations.

We process numbers in **reverse order** (from largest possible base to 1) and for each number, decide whether to **include** it or **exclude** it in forming a sum.

----------

### **Algorithm Steps:**

1.  **Determine Maximum Base**
    -   Calculate `maxNum = floor(n^(1/x))` ‚Üí the largest integer whose `x`-th power is ‚â§ `n`.
2.  **Initialize DP Table**
    -   `dp[num][sum]` = number of ways to form `sum` using numbers starting from `num`.
        
    -   Size: `(maxNum + 2) √ó (n + 1)`, initialized to 0.
        
    -   Base case: `dp[i][0] = 1` for all `i` (one way to make sum 0 ‚Üí take no numbers).
        
3.  **Fill DP Table in Reverse Order**
    -   Iterate `num` from `maxNum` down to `1`:
        1.  Compute `power = num^x`. 
        2.  For each `sum` from `0` to `n`:
            -   **Exclude current number**: `dp[num][sum] = dp[num+1][sum]`.
            -   **Include current number** (only if `sum - power >= 0`):  
                `dp[num][sum] += dp[num+1][sum - power]`.
            -   Apply modulo `1e9+7`. 
4.  **Final Answer**
    -   The answer is `dp[1][n]` ‚Üí ways to form `n` using numbers from 1 to `maxNum`.

----------

## **Time Complexity**
-   Outer loop over `num`: `O(maxNum)` ‚âà `O(n^(1/x))`.
-   Inner loop over `sum`: `O(n)`.
-   Constant-time work inside.
			Time = O(n‚ãÖn<sup>1/x</sup>)

----------
## **Space Complexity**
-   DP table of size `(maxNum+2) √ó (n+1)`:   O(n ‚ãÖ n<sup>1/x</sup>)
-   No recursion stack used.


```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
    const int MOD = 1e9+7;
public:
    int numberOfWays(int n, int x) {
        int maxNum = pow(n, 1.0 / x); // largest base possible

        vector<vector<int>> dp(maxNum+2, vector<int>(n+1, 0));

        for (int i = 0; i <= maxNum+1; i++) dp[i][0] = 1;

        for (int num = maxNum; num >= 1; num--) {
            int power = pow(num, x);
            for (int sum = 0; sum <= n; sum++) {
                dp[num][sum] = dp[num+1][sum] % MOD;
                if (sum - power >= 0) {
                    dp[num][sum] = (dp[num][sum] + dp[num+1][sum - power]) % MOD;
                }
            }
        }

        return dp[1][n];
    }
};
```



## 4Ô∏è‚É£ Space-optimized Bottom-up
## **Idea**
We want the number of ways to express `n` as a sum of **unique integers raised to the power `x`**.  
This is like a **subset sum** problem where each number‚Äôs value is `num^x` and can be chosen at most once.

Instead of a 2D DP table `(num, sum)`, we use a **1D DP array** to store ways for each sum, updating it in **reverse** to avoid reusing the same number multiple times.

----------

### **Algorithm Steps:**

1.  **Find largest possible base**
    -   `maxNum = floor(n^(1/x))` ‚Üí largest integer whose `x`th power ‚â§ `n`.
2.  **Initialize DP array**
    -   `dp[sum]` = number of ways to form `sum` using chosen numbers so far.
    -   `dp[0] = 1` (only one way to form sum 0 ‚Äî pick nothing).
3.  **Iterate over numbers from 1 to `maxNum`**
    1.  Compute `power = num^x`.
    2.  Traverse `sum` from `n` down to `power`:  
        -   Update `dp[sum] += dp[sum - power]` (modulo `1e9+7`).  
4.  **Answer**
    -   `dp[n]` gives the total number of ways.

----------

## **Time Complexity**
-   Outer loop over `num`: mmm times, where m=‚åän1/x‚åãm = \lfloor n^{1/x} \rfloorm=‚åän1/x‚åã.
-   Inner loop over `sum`: nnn times in worst case.

Time = O(m√ón)
Same as the memoized and 2D iterative versions.

----------

## **Space Complexity**
-   Uses only a **1D DP array** of size `n+1`:
Space=O(n)

This is better than the 2D DP approach O(m√ón).

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
    const int MOD = 1e9+7;
public:
    int numberOfWays(int n, int x) {
        int maxNum = pow(n, 1.0 / x);

        vector<int> dp(n+1, 0);
        dp[0] = 1; // base case

        for (int num = 1; num <= maxNum; num++) {
            int power = pow(num, x);
            for (int sum = n; sum >= power; sum--) {
                dp[sum] = (dp[sum] + dp[sum - power]) % MOD;
            }
        }

        return dp[n];
    }
};
