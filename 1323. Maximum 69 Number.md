
## [1323. Maximum 69 Number](https://leetcode.com/problems/maximum-69-number/)

You are given a positive integer  `num`  consisting only of digits  `6`  and  `9`.

Return  _the maximum number you can get by changing  **at most**  one digit (_`6` _becomes_ `9`_, and_ `9` _becomes_ `6`_)_.

**Example 1:**

**Input:** num = 9669
**Output:** 9969

**Explanation:** 
Changing the first digit results in 6669.
Changing the second digit results in 9969.
Changing the third digit results in 9699.
Changing the fourth digit results in 9666.
The maximum number is 9969.

**Example 2:**

**Input:** num = 9996
**Output:** 9999
**Explanation:** Changing the last digit 6 to 9 results in the maximum number.

**Example 3:**

**Input:** num = 9999
**Output:** 9999
**Explanation:** It is better not to apply any change.

**Constraints:**

-   `1 <= num <= 104`
-   `num` consists of only  `6`  and  `9`  digits.

## ✅ 1. String Conversion + Replace First '6' 
```cpp
class Solution {
public:
    int maximum69Number(int num) {
        string str = to_string(num);   // int → string
        for(char &ch : str) {
            if(ch == '6') {
                ch = '9';              // replace first 6
                break;
            }
        }
        return stoi(str);              // string → int
    }
};
```


🔹 **Time Complexity**: O(d) (where d = number of digits)  
🔹 **Space Complexity**: O(d)



## ✅ 2. Pure Math (No String)

``` cpp
class Solution {
public:
    int maximum69Number(int num) {
        int place = 1, res = num, temp = num;

        // Traverse digits from right to left
        while (temp > 0) {
            if (temp % 10 == 6) {
                res = num + 3 * place;  // turning 6 → 9 adds 3 × (place value)
            }
            temp /= 10;
            place *= 10;
        }
        return res;
    }
};
```

🔹 Works without `to_string` / `stoi`.  
🔹 Efficient since number ≤ 10⁴ (≤ 4 digits).  
🔹 **Time Complexity**: O(d), **Space Complexity**: O(1).


## ✅ 3. String Conversion + Replace First '6' (Index-based loop)
``` cpp
class Solution {
public:
    int maximum69Number(int num) {
        string s = to_string(num);
        for(int i = 0; i < s.size(); i++) {
            if(s[i] == '6') {
                s[i] = '9';
                break;
            }
        }
        return stoi(s);
    }
};
```
🔹 Same as approach 1 but using **index loop**.



## ✅ 4. Direct Mathematical Trick (Check Digits by Range)

Since the constraint is **num ≤ 9999**, we can solve by checking digits directly:
```cpp
class Solution {
public:
    int maximum69Number(int num) {
        if (num >= 6000 && num < 7000) return num + 3000;
        if (num >= 9600 && num < 9700) return num + 300;
        if (num >= 9960 && num < 9970) return num + 30;
        if (num == 9996) return 9999;
        return num;
    }
};

```
🔹 Uses simple **math conditions** for each possible place.  
🔹 Runs in **O(1)**.



## ✅ 5. Using `replace()` with String
```cpp
class Solution {
public:
    int maximum69Number(int num) {
        string s = to_string(num);
        size_t pos = s.find('6');   // find first occurrence
        if (pos != string::npos) {
            s[pos] = '9';
        }
        return stoi(s);
    }
};

```
🔹 Uses `find()` to directly locate the first '6'.



## ✅ 6. Recursive Approach (Not practical, but possible)
```cpp
class Solution {
public:
    int helper(string s, int i, bool changed) {
        if (i == s.size()) return stoi(s);
        if (!changed && s[i] == '6') {
            s[i] = '9';
            return stoi(s);   // stop recursion after first change
        }
        return helper(s, i+1, changed);
    }

    int maximum69Number(int num) {
        return helper(to_string(num), 0, false);
    }
};

```
🔹 Overkill for this problem, but shows recursion idea.

----------
